<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Grouping and Exporting Points</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: Arial, sans-serif; margin: 0; background: #f7f7f7; }
        h1 { color: #2c3e50; font-size: 1.4em; margin-top: 1em; }
        .container { background: #fff; padding: 1em; border-radius: 8px; box-shadow: 0 2px 8px #ccc; max-width: 98vw; margin: 1em auto; }
        input[type="file"] { margin-bottom: 1em; width: 100%; }
        .group-list { margin: 1em 0; }
        .group { margin-bottom: 0.5em; font-size: 1em; }
        .export-btn { margin-top: 1em; width: 100%; font-size: 1.1em; padding: 0.7em; }
        textarea { width: 100%; height: 120px; margin-top: 1em; font-size: 1em; }
        label { display: flex; align-items: center; gap: 0.5em; }
        @media (max-width: 600px) {
            .container { padding: 0.5em; }
            h1 { font-size: 1.1em; }
            .export-btn { font-size: 1em; }
            textarea { height: 80px; }
        }
    </style>
</head>
<body>
<div class="container">
<h1>Import, group, and export points from multiple files</h1>
<input type="file" id="fileInput" multiple accept=".txt" style="display:none;">
<button id="addFilesBtn" type="button">Add files</button>
<div id="filesContainer"></div>
<button id="exportBtn" class="export-btn" style="display:none">Export selected groups</button>
<textarea id="outputArea" readonly style="display:none"></textarea>
</div>
<script>
function parsePoints(text) {
    // Extract lines with points (robust to leading spaces, variable spaces, semicolons, and numeric names)
    const lines = text.split(/\r?\n/);
    // More flexible regex that handles various coordinate formats including negative numbers
    const pointRegex = /^\s*([^\s;]+)\s*[;\s]+([-\d\.]+)\s*[;\s]+([-\d\.]+)\s*[;\s]+([-\d\.]+)/;
    return lines.map((line, index) => {
        const m = line.match(pointRegex);
        if (m) {
            const [, name, x, y, z] = m;
            // Validate coordinates are valid numbers
            if (isNaN(parseFloat(x)) || isNaN(parseFloat(y)) || isNaN(parseFloat(z))) {
                console.warn(`Invalid coordinates on line ${index + 1}: ${line}`);
                return null;
            }
            return { name: name.trim(), line: line, x: x.trim(), y: y.trim(), z: z.trim() };
        }
        return null;
    }).filter(Boolean);
}

function groupByPattern(points) {
    // Universal regular expression for all group formats
    // Group: everything up to the first dot or dash, or the whole string if no dot/dash
    const groupMap = {};
    points.forEach(pt => {
        // Remove extra spaces and everything after the first space or semicolon
        let name = pt.name.trim();
        name = name.split(';')[0].split(/\s+/)[0];
        let group = name;
        if (/^\d{4}$/.test(name)) {
            // 4-digit numbers: 1xxx, 8xxx, etc.
            group = name[0] + 'xxx';
        } else if (/^P\d+/.test(name)) {
            // P followed by digits: Pxx
            group = 'Pxx';
        } else if (/^FP\.[A-Z]\d+\./.test(name)) {
            // FP.N1.169.2, FP.N2.100.1, FP.U1.100.1, etc.: group by first two parts (FP.N1, FP.N2, FP.U1, ...)
            let m = name.match(/^FP\.([A-Z]\d+)/);
            if (m) {
                group = 'FP.' + m[1];
            }
        } else {
            // All others: group by first part up to dot or dash
            let m = name.match(/^([^.\-]+)/);
            if (m) {
                group = m[1];
            }
        }
        if (!groupMap[group]) groupMap[group] = [];
        groupMap[group].push(pt);
    });
    return groupMap;
}


const fileInput = document.getElementById('fileInput');
const filesContainer = document.getElementById('filesContainer');
const exportBtn = document.getElementById('exportBtn');
const outputArea = document.getElementById('outputArea');
const addFilesBtn = document.getElementById('addFilesBtn');

let fileGroups = {}; // { fileKey: { groupKey: [lines] } }
let fileNames = {}; // { fileKey: fileName } - to track original names

function renderGroups() {
    filesContainer.innerHTML = '';
    Object.keys(fileGroups).forEach(fileKey => {
        const fileName = fileNames[fileKey];
        const fileDiv = document.createElement('div');
        fileDiv.className = 'group-list';
        fileDiv.style.marginBottom = '1.5em';
        const title = document.createElement('div');
        title.innerHTML = `<b>File: ${fileName}</b>`;
        fileDiv.appendChild(title);
        const groups = fileGroups[fileKey];
        Object.keys(groups).sort().forEach(key => {
            const div = document.createElement('div');
            div.className = 'group';
            div.innerHTML = `<label><input type="checkbox" data-file="${fileKey}" data-group="${key}" checked> <b>${key}</b> (${groups[key].length})</label>`;
            fileDiv.appendChild(div);
        });
        filesContainer.appendChild(fileDiv);
    });
    if (Object.keys(fileGroups).length > 0) exportBtn.style.display = '';
}

addFilesBtn.addEventListener('click', () => {
    fileInput.value = '';
    fileInput.click();
});

fileInput.addEventListener('change', async (e) => {
    outputArea.style.display = 'none';
    exportBtn.style.display = 'none';
    const files = Array.from(e.target.files);
    
    for (const file of files) {
        try {
            // Better duplicate detection using file size + name
            const fileKey = `${file.name}-${file.size}`;
            if (fileGroups[fileKey]) {
                console.log(`File ${file.name} already loaded, skipping...`);
                continue;
            }
            
            // Check file size (limit to 10MB to prevent memory issues)
            if (file.size > 10 * 1024 * 1024) {
                alert(`File ${file.name} is too large (${Math.round(file.size / 1024 / 1024)}MB). Maximum size is 10MB.`);
                continue;
            }
            
            const text = await file.text();
            if (!text.trim()) {
                alert(`File ${file.name} is empty.`);
                continue;
            }
            
            const points = parsePoints(text);
            if (points.length === 0) {
                alert(`No valid points found in file ${file.name}.`);
                continue;
            }
            
            const groups = groupByPattern(points);
            fileGroups[fileKey] = groups;
            fileNames[fileKey] = file.name;
            
        } catch (error) {
            console.error(`Error processing file ${file.name}:`, error);
            alert(`Error reading file ${file.name}: ${error.message}`);
        }
    }
    renderGroups();
});

exportBtn.addEventListener('click', () => {
    try {
        // Collect all checked groups from all files
        const checked = Array.from(filesContainer.querySelectorAll('input[type=checkbox]:checked'));
        let lines = [];
        checked.forEach(cb => {
            const fileKey = cb.getAttribute('data-file');
            const group = cb.getAttribute('data-group');
            if (fileGroups[fileKey] && fileGroups[fileKey][group]) {
                lines = lines.concat(fileGroups[fileKey][group]);
            }
        });
        
        if (lines.length === 0) {
            alert('No points selected for export.');
            return;
        }
        
        // Remove duplicates by point name
        const seen = new Set();
        lines = lines.filter(obj => {
            const name = obj.name;
            if (seen.has(name)) return false;
            seen.add(name);
            return true;
        });
        
        // Sort lines by point name (first word in line)
        lines.sort((a, b) => {
            const nameA = a.name;
            const nameB = b.name;
            return nameA.localeCompare(nameB, undefined, {numeric: true, sensitivity: 'base'});
        });
        
        // Format output with consistent indentation and columns
        const formatted = formatOutput(lines);
        outputArea.value = formatted;
        outputArea.style.display = '';
        
        // Download the file
        const blob = new Blob([outputArea.value], {type: 'text/plain'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'exported_points.txt';
        a.click();
        
    } catch (error) {
        console.error('Error during export:', error);
        alert('Error during export: ' + error.message);
    }
});

function formatOutput(lines) {
    if (lines.length === 0) return '';
    
    // Calculate column widths
    let maxNameLen = 0, maxX = 0, maxY = 0, maxZ = 0;
    
    lines.forEach(obj => {
        maxNameLen = Math.max(maxNameLen, obj.name.length);
        maxX = Math.max(maxX, obj.x.length);
        maxY = Math.max(maxY, obj.y.length);
        maxZ = Math.max(maxZ, obj.z.length);
    });
    
    // Use consistent spacing
    const INDENT = 13;
    const COL_SPACING = 7;
    
    return lines.map(obj => {
        const indent = ' '.repeat(INDENT);
        const namePad = obj.name.padStart(maxNameLen);
        const xPad = obj.x.padStart(maxX);
        const yPad = obj.y.padStart(maxY);
        const zPad = obj.z.padStart(maxZ);
        
        return `${indent}${namePad}${' '.repeat(COL_SPACING)}${xPad}${' '.repeat(COL_SPACING)}${yPad}${' '.repeat(COL_SPACING)}${zPad}`;
    }).join('\n');
}
</script>
</body>
</html>
